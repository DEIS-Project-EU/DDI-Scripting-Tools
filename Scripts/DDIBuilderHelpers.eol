/*
MIT License

Copyright (c) 2019 DEIS Project

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// ODE ProductPackages Builders

// Base Builders
operation GetID() : Integer {
	var result : Integer;
	var javaRandom : new Native("java.util.Random");
	var newID = javaRandom.nextInt(MAX_ID);
	while (ID_LIST.includes(newID))
		newID = javaRandom.nextInt(MAX_ID);
	ID_LIST.add(newID);
	return newID;
}

operation Any SetNameDescription(name : String, description : String) {
	self.name = name;
	self.description = description;
}

operation Any AddKeyValue(key : String, value : String) {
	self.AddKeyValue(key, value, "");
}

operation Any AddKeyValue(key : String, value : String, tag : String) {
	var existingEntry = self.keyValueMaps.select(entry | entry.key = key).first();
	if(not existingEntry.isDefined()) {
		var newEntry = new m!KeyValueMap;
		newEntry.key = key;
		self.keyValueMaps.add(newEntry);
		existingEntry = newEntry;
	}
	var newValue : new m!Value;
	newValue.tag = tag;
	newValue.value = value;
	existingEntry.values.add(newValue);
}

// DesignPackage Builders
operation m!DesignPackage BuildSystem(name : String, description : String) : m!System {
	var result : new m!System;
	result.SetNameDescription(name, description);
	var defaultBoundary : new m!SystemBoundary;
	defaultBoundary.name = result.name + " Default Boundary";
	result.systemBoundaries.add(defaultBoundary);
	self.systems.add(result);
	//result.SetID();
	result.Id = GetID().asLong();
	return result;
}

operation m!DesignPackage BuildSystem(name : String, description : String, parentSystem : System) {
	var result = self.BuildSystem(name, description);
	parentSystem.subSystems.add(result);
	return result;
}

operation m!DesignPackage BuildFunction(name : String, description : String) : m!Function {
	var result : new m!Function;
	result.SetNameDescription(name, description);
	self.functions.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!System BuildPort(name : String, description : String) : m!Port {
	var result : new m!Port;
	result.SetNameDescription(name, description);
	result.direction = m!PortDirection#INOUT;
	self.ports.add(result);
	self.systemBoundaries.first().ports.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!System BuildPort(name : String, description : String, direction : String) : m!Port {
	var result = self.BuildPort(name, description);
	result.SetDirection(direction);
	return result;
}

operation m!Function BuildPort(name : String, description : String, direction : String) : m!Port {
	var result : new m!Port;
	result.SetNameDescription(name, description);
	self.ports.add(result);
	result.SetDirection(direction);
	result.Id = GetID().asLong();
	return result;
}

operation m!Port SetDirection(direction : String) {
	if (direction = "IN")
		self.direction = m!PortDirection#IN;
	else if (direction = "OUT")
		self.direction = m!PortDirection#OUT;
	else // if (direction = "INOUT")
		self.direction = m!PortDirection#INOUT;
}

operation m!System BuildSignal(name : String, description : String, fromPort : m!Port, toPort : m!Port) : m!Signal {
	var result : new m!Signal;
	result.SetNameDescription(name, description);
	result.fromPort = fromPort;
	result.toPort = toPort;
	self.signals.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!System BuildSignal(fromPort : m!Port, toPort : m!Port) : m!Signal {
	return self.BuildSignal("", "", fromPort, toPort);	
}

operation m!System AddFailureModel(fm : m!FailureModel) {
	self.failureModels.add(fm);
}

operation m!Port AddFailure(f : m!Failure) {
	self.interfaceFailures.add(f);
}

operation m!Port AddFailure(f : m!Cause) {
	self.AddFailure(f.failure);
}

// FailurePackage Builders
operation m!FailureLogicPackage BuildFaultTree(name : String) : m!FaultTree {
	var result : new m!FaultTree;
	result.name = name;
	self.failureModels.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!FailureLogicPackage BuildFaultTree(name : String, parent : m!FailureModel) : m!FaultTree {
	var result = self.BuildFaultTree(name);
	parent.subModels.add(result);
	return result;
}

operation m!FailureModel BuildFailure(name : String, description : String, failureClass : String, failureRate : Real, isCCF : Boolean, originType : String) : m!Failure {
	var result : new m!Failure;
	result.SetNameDescription(name, description);
	result.failureClass = failureClass;
	if(not (failureRate = 0.0d)) {
		var probDist : new m!ProbDist;
		probDist.type = "Fit";
		probDist.Id = GetID().asLong();
		var probDistParam : new m!ProbDistParam;
		probDistParam.name = "Value";
		probDistParam.Id = GetID().asLong();
		probDistParam.value = failureRate.asString();
		probDist.parameters.add(probDistParam);
		result.failureProbDistribution = probDist;
	}
	result.isCcf = isCCF;
	result.SetOriginType(originType);
	self.failures.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!FaultTree BuildGate(name : String, gateType : String) : m!Gate {
	var result = self.BuildGate(gateType);
	result.name = name;
	return result;
}

operation m!FaultTree BuildGate(gateType : String) : m!Gate {
	var result : new m!Gate;
	result.SetGateType(gateType);
	result.SetCauseType("GATE");
	self.causes.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!Gate AddCause(c : m!Cause) {
	self.causes.add(c);
}

operation m!FaultTree BuildBasicEvent(name : String, description : String, failureClass : String, failureRate : Real, isCCF : Boolean) : m!Cause {
	var result : new m!Cause;
	result.SetNameDescription(name, description);
	var linkedFailure = self.BuildFailure(name, description, failureClass, failureRate, isCCF, "INTERNAL");
	result.SetCauseType("INTERNAL");
	self.causes.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!FaultTree BuildInputEvent(name : String, description : String, failureClass : String, failureRate : Real, isCCF : Boolean) : m!Gate {
	var result : new m!Gate;
	result.SetNameDescription(name, description);
	var linkedFailure = self.BuildFailure(name, description, failureClass, failureRate, isCCF, "INPUT");
	result.failure = linkedFailure;
	result.SetCauseType("INPUT");
	result.SetGateType("INPUT");
	self.causes.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!FaultTree BuildOutputEvent(name : String, description : String, failureClass : String, failureRate : Real, isCCF : Boolean) : m!Gate {
	var result : new m!Gate;
	result.SetNameDescription(name, description);
	var linkedFailure = self.BuildFailure(name, description, failureClass, failureRate, isCCF, "OUTPUT");
	result.failure = linkedFailure;
	result.SetCauseType("OUTPUT");
	result.SetGateType("OUTPUT");
	self.causes.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!Failure SetOriginType(originType : String) {
	if (originType = "INPUT")
		self.originType = m!FailureOriginType#Input;
	else if (originType = "OUTPUT")
		self.originType = m!FailureOriginType#Output;
	else //if (originType = "INTERNAL")
		self.originType = m!FailureOriginType#Internal;
}

operation m!Gate SetGateType(gateType : String) {
	if (gateType = "OR")
		self.gateType = m!GateType#OR;
	else if (gateType = "AND")
		self.gateType = m!GateType#AND;
	else if (gateType = "NOT")
		self.gateType = m!GateType#NOT;
	else if (gateType = "XOR")
		self.gateType = m!GateType#XOR;
	else if (gateType = "VOTE")
		self.gateType = m!GateType#VOTE;
	else if (gateType = "PAND")
		self.gateType = m!GateType#PAND;
	else if (gateType = "SAND")
		self.gateType = m!GateType#SAND;
	else if (gateType = "INPUT")
		self.gateType = m!GateType#InputEvent;
	else // if (gateType = "OUTPUT")
		self.gateType = m!GateType#OutputEvent;
}

operation m!Cause SetCauseType(causeType : String) {
	if (causeType = "INPUT")
		self.causeType = m!CauseType#InputEvent;
	else if (causeType = "OUTPUT")
		self.causeType = m!CauseType#OutputEvent;
	else if (causeType = "GATE")
		self.causeType = m!CauseType#Gate;
	else // if (causeType = "INTERNAL")
		self.causeType = m!CauseType#BasicEvent;
}

// Dependability Package Builders
operation m!HARAPackage BuildHazardType(name : String, description : String) : m!HazardType {
	var result : new m!HazardType;
	result.SetNameDescription(name, description);
	self.hazardTypes.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!HARAPackage BuildHazard(name : String, description : String, condition : String, hazardType : m!HazardType, failures : Collection, measures : Collection) : m!Hazard {
	var result : new m!Hazard;
	result.SetNameDescription(name, description);
	result.condition = condition;
	result.hazardType = hazardType;
	result.failures.addAll(failures);
	result.measures.addAll(measures);
	self.hazards.add(result);
	result.Id = GetID().asLong();
	return result;
}

operation m!HARAPackage BuildMalfunction(name : String, description : String, hazards : Collection) : m!Malfunction {
	var result : new m!Malfunction;
	result.SetNameDescription(name, description);
	result.hazards.addAll(hazards);
	self.malfunctions.add(result);
	result.Id = GetID().asLong();
	return result;
}

// SACM Builders

// Sets the ModelElement's name within a LangString
// Name set to input, language assumed 'en'
operation m!ModelElement SetName(input : String) {
	var name : new m!LangString;
	name.lang = "en";
	name.content = input;
	self.name = name;
}

operation BuildLangString(content : String, lang : String) : m!LangString {
	var result : new m!LangString;
	result.lang = lang;
	result.content = content;
	return result;
}

operation m!MultiLangString BuildLangString(lang : String, content : String) : m!LangString {
	var result : new m!LangString;
	result.lang = lang;
	result.content = content;
	self.value.add(result);
	return result;	
}

operation m!ModelElement BuildTaggedValue(key : String, value : String) : m!TaggedValue {
	var result : new m!TaggedValue;
	result.key = new m!MultiLangString;
	result.key.BuildLangString(key, value);
	self.taggedValue.add(result);
	result.gid = GetID().asString();
	return result;
}

operation BuildExpressionLangString(expression : m!ExpressionElement) : m!ExpressionLangString {
	var result : new m!ExpressionLangString;
	result.expression = expression;
	return result;
}

// Sets the ModelElement's description within a Description,
// MultiLangString, then LangString
// Description set to input, language assumed to be 'en'
operation m!ModelElement SetDescription(input : String) {
	self.description = new m!Description;
	self.description.content = new m!MultiLangString;
	var descContentValue : new m!LangString;
	descContentValue.lang = "en";
	descContentValue.content = input;
	self.description.content.value.add(descContentValue);
}

// Constructs a 'Goal' i.e. SACM Claim
// Adds it to the subject ArgumentPackage's argumentationElement(s)
// Name of claim set to name, Description of claim set to description
// Returns constructed goal
operation m!ArgumentPackage BuildGoal(name : String, description : String) : m!Claim {
	var result : new m!Claim;
	result.SetName(name);
	result.SetDescription(description);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!ArgumentPackage BuildGoal(name : String, description : Collection) : m!Claim {
	var result : new m!Claim;
	result.SetName(name);
	result.SetDescription(description);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Constructs an 'Assumption' i.e. SACM Claim with assertionDeclaration = 'assumed'
// Adds it to the subject ArgumentPackage's argumentationElement(s)
// Name of claim set to name, Description of claim set to description
// Returns constructed assumption
operation m!ArgumentPackage BuildAssumption(name : String, description : String) : m!Claim {
	var result = self.BuildGoal(name, description);
	result.assertionDeclaration = m!AssertionDeclaration#assumed;
	return result;
}

// Constructs a 'Justification' i.e. SACM Claim with assertionDeclaration = 'axiomatic'
// Adds it to the subject ArgumentPackage's argumentationElement(s)
// Name of claim set to name, Description of claim set to description
// Returns constructed justification
operation m!ArgumentPackage BuildJustification(name : String, description : String) : m!Claim {
	var result = self.BuildGoal(name, description);
	result.assertionDeclaration = m!AssertionDeclaration#axiomatic;
	return result;
}

// Constructs a 'Strategy' i.e. SACM AssertedInference with (optional) ArgumentReasoning
// Adds it to the subject ArgumentPackage's argumentationElement(s)
// Name of strategy set to name, Description of strategy set to description
// If name is empty, then no ArgumentReasoning is generated
// Returns constructed strategy
operation m!ArgumentPackage BuildStrategy(name : String, description : String) : m!AssertedInference {
	var result : new m!AssertedInference;
	if(not (name = "")) {
		result.reasoning = new m!ArgumentReasoning;
		result.reasoning.SetName(name);
		result.reasoning.SetDescription(description);
		self.argumentationElement.add(result.reasoning);
	}
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!ArgumentPackage BuildStrategy(name : String, description : Collection) : m!AssertedInference {
	var result : new m!AssertedInference;
	result.reasoning = new m!ArgumentReasoning;
	result.reasoning.SetName(name);
	result.reasoning.SetDescription(description);
	self.argumentationElement.add(result.reasoning);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Constructs a 'Context' i.e. SACM ArtifactReference
// Adds it to the subject ArgumentPackage's argumentationElement(s)
// Name of context set to name, Description of context set to description
// Returns constructed context
operation m!ArgumentPackage BuildContext(name : String, description : String) : m!ArtifactReference {
	var result : new m!ArtifactReference;
	result.SetName(name);
	result.SetDescription(description);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Constructs a 'Solution' i.e. SACM ArtifactReference
// Adds it to the subject ArgumentPackage's argumentationElement(s)
// Name of solution set to name, Description of solution set to description
// Returns constructed solution
operation m!ArgumentPackage BuildSolution(name : String, description : String) : m!ArtifactReference {
	var result : new m!ArtifactReference;
	result.SetName(name);
	result.SetDescription(description);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Constructs an Artifact
// Adds it to the subject ArtifactPackage's artifactElement(s)
// Name of artifact set to name, Description of artifact set to description, Version of artifact set to version
// Date of artifact set to string conversion using java.util.Date
// Returns constructed artifact
operation m!ArtifactPackage BuildArtifact(name : String, description : String, version : String, date : String) : m!Artifact {
	var result : new m!Artifact;
	result.SetName(name);
	result.SetDescription(description);
	result.version = version;
	result.date = new Native("java.util.Date");
	var parsedDate = result.date.parse(date);
	result.date.setTime(parsedDate);
	self.artifactElement.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!ArtifactPackage BuildActivity(name : String, description : String, startTime : String, endTime : String) : m!Activity {
	var result : new m!Activity;
	result.SetName(name);
	result.SetDescription(description);
	result.startTime = new Native("java.util.Date");
	var parsedStartTime = result.startTime.parse(startTime);
	result.startTime.setTime(parsedStartTime);
	result.endTime = new Native("java.util.Date");
	var parsedEndTime = result.endTime.parse(endTime);
	result.endTime.setTime(parsedEndTime);
	self.artifactElement.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!ArtifactPackage BuildEvent(name : String, description : String, occurence : String) : m!Event {
	var result : new m!Event;
	result.SetName(name);
	result.SetDescription(description);
	result.occurence = new Native("java.util.Date");
	var parsedOccurence = result.occurence.parse(occurence);
	result.occurence.setTime(parsedOccurence);
	self.artifactElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Links a 'Strategy' (SACM AssertedInference) to zero or more 'Contexts' (ArtifactReferences) via an AssertedContext
// Adds new AssertedContext to the subject ArgumentPackage's argumentationElement(s)
// Returns AssertedContext
operation m!ArgumentPackage LinkStrategyToContexts(s : m!AssertedInference, c : Collection, name : String, description : String) : m!AssertedContext {
	var result : new m!AssertedContext;
	result.target.add(s);
	for (context in c) { 
		result.source.add(context);
	}
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Links a Strategy to a single Context via an AssertedContext
// Adds new AssertedContext to the subject ArgumentPackage
// Returns AssertedContext 
operation m!ArgumentPackage LinkStrategyToContext(s : m!AssertedInference, c : m!ArtifactReference) : m!AssertedContext {
	var result : new m!AssertedContext;
	result.target.add(s);
	result.source.add(c);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Links Goal to subGoals
// Adds linking Strategy to subject ArgumentPackage
// If name and description are provided, strategy contains ArgumentReasoning accordingly 
// Returns linking strategy
operation m!ArgumentPackage LinkGoalToGoals(target : m!Claim, subGoals : Collection, strategyName : String, strategyDescription : String) : m!AssertedInference {
	var result = self.BuildStrategy(strategyName, strategyDescription);
	for (subGoal in subGoals) {
		result.source.add(subGoal);
	}
	result.target.add(target);
	return result;
}

operation m!ArgumentPackage LinkGoalToGoals(target : m!Claim, subGoals : Collection) : m!AssertedInference {
	return self.LinkGoalToGoals(target, subGoals, "", "");
}

// Links Goal to subGoal
// Adds linking Strategy to subject ArgumentPackage
// If name and description are provided, strategy contains ArgumentReasoning accordingly
// Returns linking strategy
operation m!ArgumentPackage LinkGoalToGoal(target : m!Claim, subGoal : m!Claim, strategyName : String, strategyDescription : String) : m!AssertedInference {
	var result = self.BuildStrategy(strategyName, strategyDescription);
	result.source.add(subGoal);
	result.target.add(target);
	return result;
}

// Links Goal to evidence (Collection of ArtifactReferences)
// Adds linking AssertedEvidence to subject ArgumentPackage
// Returns linking AssertedEvidence 
operation m!ArgumentPackage LinkGoalToEvidence(target : m!Claim, evidence : Collection) : m!AssertedEvidence {
	var result : new m!AssertedEvidence;
	result.target.add(target);
	for(item in evidence) {
		result.source.add(item);
	}
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}


// This isn't proper, consider removing
operation m!ArgumentPackage LinkGoalToEvidence(target : m!Claim, evidence : Collection, strategyName : String, strategyDescription : String) : m!AssertedEvidence {
	var result = self.LinkGoalToEvidence(target, evidence);
	result.reasoning = new m!ArgumentReasoning;
	result.reasoning.SetName(strategyName);
	result.reasoning.SetDescription(strategyDescription);
	result.reasoning.gid = GetID().asString();
	self.argumentationElement.add(result.reasoning);
	return result;	
}

// Links Goal to single evidence (ArtifactReference)
// Adds linking AssertedEvidence to subject ArgumentPackage
// Returns linking AssertedEvidence 
operation m!ArgumentPackage LinkGoalToEvidence(target : m!Claim, evidence : m!ArtifactReference) : m!AssertedEvidence {
	var result : new m!AssertedEvidence;
	result.source.add(evidence);
	result.target.add(target);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;	
}

// Links Goal to Contexts (Collection of ArtifactReferences)
// Adds linking AssertedContext to subject ArgumentPackage
// Returns linking AssertedContext
operation m!ArgumentPackage LinkGoalToContexts(target : m!Claim, contexts : Collection) : m!AssertedContext {
	var result : new m!AssertedContext;
	result.target.add(target);
	for(item in contexts) {
		result.source.add(item);
	}
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Links Goal to single Context (ArtifactReference)
// Adds linking AssertedEvidence to subject ArgumentPackage
// Returns linking AssertedEvidence 
operation m!ArgumentPackage LinkGoalToContext(target : m!Claim, context : m!ArtifactReference) : m!AssertedContext {
	var result : new m!AssertedContext;
	result.source.add(context);
	result.target.add(target);
	self.argumentationElement.add(result);
	result.gid = GetID().asString();
	return result;
}

// Links ArtifactReference (e.g. Solution, Context) to Artifact
operation m!ArtifactReference LinkToArtifact(target : m!ArtifactElement) {
	self.referencedArtifactElement.add(target);
}

operation m!Term SetType(type : String) {
	self.SetName(type);
}

operation m!Term GetType() : String {
	return self.GetName();
}

operation m!TerminologyPackage BuildTerm(name : String) : m!Term {
	var result : new m!Term;
	result.SetName(name);
	self.terminologyElement.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!TerminologyPackage BuildTerm(type : String, value : String) : m!Term {
	var result : new m!Term;
	result.SetType(type);
	result.value = value;
	result.gid = GetID().asString();
	return result;	
}

operation m!TerminologyPackage BuildExpression(name : String) : m!Expression {
	var result : new m!Expression;
	result.SetName(name);
	self.terminologyElement.add(result);
	result.gid = GetID().asString();
	return result;
}

$pre expressions.forAll(e | e.isKindOf(m!ExpressionElement))
operation m!TerminologyPackage BuildExpression(name : String, expressions : Collection) : m!Expression {
	var result = self.BuildExpression(name);
	for (expression in expressions) {
		result.element.add(expression);
	}
	return result;
}

$pre expressions.forAll(e | e.isKindOf(m!ExpressionElement))
operation m!TerminologyPackage BuildExpression(expressions : Collection) : m!Expression {
	var result : new m!Expression;
	var name : String;
	for (expression in expressions) {
		result.element.add(expression);
		name += expression.name.content;
	}
	result.SetName(name);
	self.terminologyElement.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!ModelElement BuildImplementationConstraint(expression : ExpressionElement) : m!ImplementationConstraint {
	var result : new m!ImplementationConstraint;
	var content : new m!MultiLangString;
	result.content = content;
	var expLangString = BuildExpressionLangString(expression);
	content.value.add(expLangString);
	self.implementationConstraint.add(result);
	result.gid = GetID().asString();
	return result;
}

operation m!TerminologyPackage FindTermExternalReference(name : String) : String {
	// Assumption: Only Terms should match
	var foundTerm : m!Term = self.terminologyElement.selectOne(t | t.GetName() = name);
	
	if(foundTerm.isDefined())
		if(foundTerm.externalReference.isDefined())
			return base.getElementById(foundTerm.externalReference).name;
			
	return ""; 
}

operation m!ExpressionLangString GetName() : String {
	return self.expression.GetName();
}

operation m!ModelElement GetName() : String {
	if(self.name.isDefined())
		if(self.name.content.isDefined())
			return self.name.content;
	return "";
}

operation m!AssertedInference GetName() : String {
	if(self.reasoning.isDefined())
		return self.reasoning.GetName();
	return "";
}

operation m!Claim GetDescription() : String {
	if(not self.description.isDefined())
		return "";
	if(not self.description.content.isDefined())
		return "";
	if(not (self.description.content.value.size() > 0))
		return "";
	return self.description.content.value.first().content;
}

operation m!AssertedInference GetDescription() : String {
	if(not self.reasoning.isDefined())
		return "";
	if(not self.reasoning.description.content.isDefined())
		return "";
	if(not (self.reasoning.description.content.value.size() > 0))
		return "";
	return self.reasoning.description.content.value.first().content;
}

operation m!AssertedInference HasImplementationConstraint() : Boolean {
	if(self.reasoning.isDefined())
		if(self.reasoning.implementationConstraint.size() > 0)
			return true;
	return false;
}
